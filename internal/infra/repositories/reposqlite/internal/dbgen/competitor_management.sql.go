// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: competitor_management.sql

package dbgen

import (
	"context"
)

const GetCompetitor = `-- name: GetCompetitor :one
SELECT c.id,
       c.code,
       c.name,
       c.country_id
FROM competitors c
WHERE c.code = ?
  AND c.name = ?
  AND c.country_id = ?
`

type GetCompetitorParams struct {
	Code      string `db:"code"`
	Name      string `db:"name"`
	CountryID int64  `db:"country_id"`
}

type GetCompetitorRow struct {
	ID        int64  `db:"id"`
	Code      string `db:"code"`
	Name      string `db:"name"`
	CountryID int64  `db:"country_id"`
}

func (q *Queries) GetCompetitor(ctx context.Context, arg GetCompetitorParams) (GetCompetitorRow, error) {
	row := q.db.QueryRowContext(ctx, GetCompetitor, arg.Code, arg.Name, arg.CountryID)
	var i GetCompetitorRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.CountryID,
	)
	return i, err
}

const GetCompetitorByCountry = `-- name: GetCompetitorByCountry :many
SELECT c.id,
       c.code,
       c.name,
       c.country_id
FROM competitors c
         JOIN
     country_infos ci ON c.country_id = ci.id
WHERE ci.iso_code_len2 = ?
   OR ci.iso_code_len3 = ?
`

type GetCompetitorByCountryParams struct {
	IsoCodeLen2 interface{} `db:"iso_code_len2"`
	IsoCodeLen3 string      `db:"iso_code_len3"`
}

type GetCompetitorByCountryRow struct {
	ID        int64  `db:"id"`
	Code      string `db:"code"`
	Name      string `db:"name"`
	CountryID int64  `db:"country_id"`
}

func (q *Queries) GetCompetitorByCountry(ctx context.Context, arg GetCompetitorByCountryParams) ([]GetCompetitorByCountryRow, error) {
	rows, err := q.db.QueryContext(ctx, GetCompetitorByCountry, arg.IsoCodeLen2, arg.IsoCodeLen3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCompetitorByCountryRow{}
	for rows.Next() {
		var i GetCompetitorByCountryRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.CountryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetEventCompetitors = `-- name: GetEventCompetitors :many
SELECT c.name,
       c.code,
       ci.name AS country_name,
       ci.code AS country_code,
       ci.ioc_code,
       ci.iso_code_len2,
       ci.iso_code_len3
FROM competitors c
         INNER JOIN
     results r ON c.id = r.competitor_id
         INNER JOIN main.country_infos ci on ci.id = c.country_id
WHERE r.event_id = ?
`

type GetEventCompetitorsRow struct {
	Name        string      `db:"name"`
	Code        string      `db:"code"`
	CountryName string      `db:"country_name"`
	CountryCode string      `db:"country_code"`
	IocCode     string      `db:"ioc_code"`
	IsoCodeLen2 interface{} `db:"iso_code_len2"`
	IsoCodeLen3 string      `db:"iso_code_len3"`
}

func (q *Queries) GetEventCompetitors(ctx context.Context, eventID int64) ([]GetEventCompetitorsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetEventCompetitors, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventCompetitorsRow{}
	for rows.Next() {
		var i GetEventCompetitorsRow
		if err := rows.Scan(
			&i.Name,
			&i.Code,
			&i.CountryName,
			&i.CountryCode,
			&i.IocCode,
			&i.IsoCodeLen2,
			&i.IsoCodeLen3,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SaveCompetitor = `-- name: SaveCompetitor :one
INSERT INTO competitors (code, name, country_id)
VALUES (?, ?, ?)
ON CONFLICT (code, name, country_id) DO NOTHING
RETURNING id
`

type SaveCompetitorParams struct {
	Code      string `db:"code"`
	Name      string `db:"name"`
	CountryID int64  `db:"country_id"`
}

func (q *Queries) SaveCompetitor(ctx context.Context, arg SaveCompetitorParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, SaveCompetitor, arg.Code, arg.Name, arg.CountryID)
	var id int64
	err := row.Scan(&id)
	return id, err
}
